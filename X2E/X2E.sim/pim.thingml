/* ThingML Framework */

// Base datatypes
import "datatypes.thingml"

// Import everything in core [where is core?]
// import "core/scheduler.thingml"
// import "core/timer.thingml"

/* PSM must be included */
import "psm_sim.thingml"
import "psm_datatypes_sim.thingml"
import "pim_messages.thingml"
import "timer.thingml"

thing PIM includes GeneralMsg, TemperatureMsg, OnOffMsg, WindowMsg, DoorMsg {
	/*provided port get_sensor {
		receives temperature
	}
	required port request_sensor {
		sends add_thermometer, set_polling_interval
	}
	required port request_actuator{
		sends add_device, SwitchOn, SwitchOff
	}
	provided port human_input {
		receives add_thermometer, add_device, SwitchOn, SwitchOff, set_temperature, set_polling_interval
	}
	required port human_output {
		sends temperature, prompt
	}*/
	required port thermostat_output {
		sends temperature, prompt
	}
	provided port thermostat_input {
		receives set_temperature
	}
	provided port wall_temp {
		receives temperature
	}
	required port wall_heater {
		sends SwitchOn, SwitchOff
	}
	required port window1_output {
		sends set_id, set_temperature, SwitchOff, SwitchOn
	}
	provided port windows_input {
		receives opened, shut, temperature
	}
	required port window2_output {
		sends set_id, set_temperature,  SwitchOff, SwitchOn
	}
	provided port door_input {
		receives opened, shut, locked
	}
	
	property tmrature:Double   // the requested temperature for the room
	property thermo_id:Integer // the single thermometer identifier
	property switch_id:Integer // the single on-off switch identifier
	
	property temp_up_or_down:Integer = 0 // 0 = no on or off message sent yet, 1 = off 2 = on;
	
	// Magnet swtiches states
	property window1_state:Boolean = true //starts closed
	property window2_state:Boolean = true // starts closed
	property door_locked:Boolean
	
	// Got temp from windows?
	property window1_gotTemp:Boolean
	property window2_gotTemp:Boolean
	
	// Last read temperatures
	property temp_wall:Double
	property temp_window1:Double
	property temp_window2:Double
	
	// Rooms average temperature
	property avgTemp:Double
	
	function UpdateHeaters() do
		println("Calculating average temperature")
		
		// Only wall is viable
		if(not (window1_state and window1_gotTemp) and not (window2_state and window2_gotTemp)) do
			println("Only wall is viable temperature")
			avgTemp = temp_wall
		end
		
		// Window 1 and wall is viable
		else if((window1_state and window1_gotTemp) and not (window2_state and window2_gotTemp)) do
			println("Wall and window1 are viable temperatures")
			avgTemp = (temp_wall + temp_window1)/2
		end
		
		// Window 2 and wall is viable
		else if(not (window1_state and window1_gotTemp) and (window2_state and window2_gotTemp)) do
			println("Wall and window2 are viable temperatures")
			avgTemp = (temp_wall + temp_window2)/2
		end
		
		// Both windows and wall is viable
		else if((window1_state and window1_gotTemp) and (window2_state and window2_gotTemp)) do
			println("Wall and both windows are viable temperatures")
			avgTemp = (temp_wall + temp_window1 + temp_window2)/3
		end
		
		println("Average Temp is = " + avgTemp)
		
		
		println("Turning heaters on or off")
		// Initial
		if(temp_up_or_down == 0) do
			if(avgTemp>=tmrature-1) do
				wall_heater!SwitchOff(0)
				window1_output!SwitchOff(1)
				window2_output!SwitchOff(2)
				temp_up_or_down = 1
			end
			else do
				wall_heater!SwitchOn(0)
				window1_output!SwitchOn(1)
				window2_output!SwitchOn(2)
				temp_up_or_down = 2
			end
		end
						
		// Decrease Temp
		else if(temp_up_or_down == 1) do
			if(avgTemp<tmrature-1) do
				wall_heater!SwitchOn(0)
				window1_output!SwitchOn(1)
				window2_output!SwitchOn(2)
				temp_up_or_down = 2
			end
		end
						
		// Increase Temp
		else if(temp_up_or_down == 2) do
			if(avgTemp>tmrature+1) do
				wall_heater!SwitchOff(0)
				window1_output!SwitchOff(1)
				window2_output!SwitchOff(2)
				temp_up_or_down = 1
			end
		end
	end
	
	statechart PIM_behavior init Build {
		//Start at SetThermostat instead of AddThermo as we know we have one Thermometer and one heater.
		state Build {
					on entry do
					// Add windows
				  	window1_output!set_id(1)
				  	window2_output!set_id(2)
					end			
/* Old States
			state AddThermo {
				transition -> AddDevice
				event addt:human_input?add_thermometer
				action do
					thermo_id=addt.id
					request_sensor!add_thermometer(thermo_id,addt.txt)
					human_output!prompt("Please add one switch device") // SIMULATION: prompting on console for the user to react properly
				end
				transition -> AddThermo // Cover other messages
				event human_input?add_device
				action do
					human_output!prompt("Please add thermometer")
				end
				transition -> AddThermo // Cover other messages
				event human_input?SwitchOn
				action do
					human_output!prompt("Please add thermometer")
				end
				transition -> AddThermo // Cover other messages
				event human_input?SwitchOff
				action do
					human_output!prompt("Please add thermometer")
				end
				transition -> AddThermo // Cover other messages
				event human_input?set_temperature
				action do
					human_output!prompt("Please add thermometer")
				end
				transition -> AddThermo // Cover other messages
				event human_input?set_polling_interval
				action do
					human_output!prompt("Please add thermometer")
				end
				// temperature is handled on Build level
			}
			state AddDevice {
				transition -> SetThermostat
				event adddev:human_input?add_device
				action do
					switch_id=adddev.did
					request_actuator!add_device(switch_id)
					human_output!prompt("Please give thermostat temperature setting") // SIMULATION: prompting on console for the user to react properly
				end
				
				transition -> AddDevice
				event human_input?SwitchOn
				action do
					human_output!prompt("Please add device")
				end
				transition -> AddDevice
				event human_input?SwitchOff
				action do
					human_output!prompt("Please add device")
				end
				transition -> AddDevice
				event human_input?set_polling_interval
				action do
					human_output!prompt("Please add device")
				end
				transition -> AddDevice
				event human_input?add_thermometer
				action do
					human_output!prompt("Thermometer already added, add device")
				end
				// temperature and set_temperature handled on Build level
			}
			
			final state SetThermostat {
				
				// Here the only message we want is the set_temperature, but this is on one level up to move to Running
				/*transition -> SetThermostat
				event human_input?add_thermometer
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end			
				transition -> SetThermostat
				event human_input?add_device
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end			
				transition -> SetThermostat
				event human_input?SwitchOn
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end			
				transition -> SetThermostat
				event human_input?SwitchOff
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end			
				transition -> SetThermostat
				event human_input?set_polling_interval
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end			
			}*/
			
			// Normal transition to the Running state
			transition -> Running
			event set_temp:thermostat_input?set_temperature//set_temp:human_input?set_temperature
			action do
				tmrature = set_temp.t
				window1_output!set_temperature(tmrature)
				window2_output!set_temperature(tmrature)

				thermostat_output!prompt("Please set a desired temperature") // SIMULATION: prompting on console for the user to react properly
			end
			
			/*
			//Escape situations
			transition -> Build
			event wall_temp?temperature 
				// just discard, the thermostat is not running, yet (161103)
				*/
				
		} // end Build
		
		composite state Running init DoorNotLocked keeps history {
		
			state DoorNotLocked {
				transition -> DoorNotLocked
				event temp:wall_temp?temperature
				action do
					temp_wall = temp.t
					UpdateHeaters()
				end
				transition -> DoorNotLocked
				event temp:windows_input?temperature
				action do
				if(temp.id == 1) do
				window1_gotTemp = true
				temp_window1 = temp.t
				end
				else if (temp.id == 2) do
				window2_gotTemp = true
				temp_window2 = temp.t
				end
					UpdateHeaters()
				end
				transition -> DoorNotLocked
				event opened:windows_input?opened
				action do
					if(opened.wid == 1) do
						window1_state = false
					end
					else if(opened.wid == 2) do
						window2_state = false
					end
					UpdateHeaters()
				end
				transition -> DoorNotLocked
				event shut:windows_input?shut
				action do
					if(shut.wid == 1) do
						window1_state = true
					end
					else if(shut.wid == 2) do
						window2_state = true
					end
					UpdateHeaters()
				end
				transition -> DoorLocked
				event door_input?locked
				action do
					if(not window1_state or not window2_state) do
						println("WARNING, DOOR LOCKED WITH WINDOW OPEN")
						if(window1_state and not window2_state) do
							thermostat_output!prompt("WARNING: Window 2 is open!")
						end
						if(not window1_state and window2_state) do
							thermostat_output!prompt("WARNING: Window 1 is open!")
						end
						else do
							thermostat_output!prompt("WARNING: Both windows are open!")
						end
					end
				end
			}
			
			state DoorLocked {
				on entry do
				println("NOW IN LOCKED STATE")
				end
				
				transition -> DoorLocked
				event temp:wall_temp?temperature
				action do
					temp_wall = temp.t
					UpdateHeaters()
				end
				transition -> DoorLocked
				event temp:windows_input?temperature
				action do
				if(temp.id == 1) do
				window1_gotTemp = true
				temp_window1 = temp.t
				end
				else if (temp.id == 2) do
				window2_gotTemp = true
				temp_window2 = temp.t
				end
					UpdateHeaters()
				end
				transition -> DoorLocked
				event opened:windows_input?opened
				action do
					if(opened.wid == 1) do
						window1_state = false
					end
					else if(opened.wid == 2) do
						window2_state = false
					end
					UpdateHeaters()
					println("ALARM: Window" + opened.wid + " was opened while in a locked state!")
					thermostat_output!prompt("ALARM: Window" + opened.wid + " was opened!")
				end
				transition -> DoorLocked
				event shut:windows_input?shut
				action do
					if(shut.wid == 1) do
						window1_state = true
					end
					else if(shut.wid == 2) do
						window2_state = true
					end
					UpdateHeaters()
				end
			}
		
		/* 
			composite state Thermostat init TemprDecide {  // notice that we are not keeping history, we do not know whether to turn on or off
				
				
				state TemprDecide {
					transition -> TemprDecrease
					event temp2:get_sensor?temperature
					guard temp2.t>=tmrature-1  // We choose switch OFF as much as we can here
					action do
						request_actuator!SwitchOff(switch_id)
					end
					
					transition -> TemprIncrease
					event temp2:get_sensor?temperature
					guard temp2.t<tmrature-1
					action do
						request_actuator!SwitchOn(switch_id)
					end
				}
				
				state TemprIncrease{ // Invariant: Switch is ON and temperature should increase
				
					transition -> TemprIncrease 
					event temp:get_sensor?temperature
					guard temp.t<=tmrature+1 // it should keep increasing until well above the desired temperature
					action do
						// TRACING to follow thermostat print("TempIncrease: Observed=") print(temp.t) print(" Desired ") print(tmrature) print("\n") 
					end
					
					transition -> TemprDecrease
					event temp2:get_sensor?temperature
					guard temp2.t>tmrature+1 
					action do
						request_actuator!SwitchOff(switch_id)
					end
				}

				state TemprDecrease{ // Invariant: Switch is OFF and temperature should decrease
				
					transition-> TemprDecrease
					event temp:get_sensor?temperature
					guard temp.t>=tmrature-1 // it should keep decreasing until well below the desired temperature
					action do
						// TRACING to follow thermostat print("TempDecrease: Observed=") print(temp.t) print(" Desired ") print(tmrature) print("\n") 
					end
					
					transition -> TemprIncrease
					event temp2:get_sensor?temperature
					guard temp2.t<tmrature-1
					action do
						request_actuator!SwitchOn(switch_id)
					end
				}
				
				transition -> On
				event swon:human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end 
				transition -> Off
				event swoff:human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end 
				
				transition -> Thermostat
				event set_temp:thermostat_input?set_temperature
				action do
					tmrature = set_temp.t
					window1_output!set_temperature(tmrature)
				end
			} // end Thermostat
			
			state On {
				transition -> Off
				event swoff:human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end 
				transition -> On
				event swon:human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp:human_input?set_temperature
				action do
					tmrature = set_temp.t
				window1_output!set_temperature(tmrature)
				end
			}
			state Off {
				transition -> Off
				event swoff:human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end 
				transition -> On
				event swon:human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp:human_input?set_temperature
				action do
					tmrature = set_temp.t
				window1_output!set_temperature(tmrature)
				end	
			}
			
			  */
			  
			// Transitions of the composite state Running
			/*transition -> Running
			event pollint:human_input?set_polling_interval
			action do
				// just forward the polling interval instructions to the PSM
				request_sensor!set_polling_interval(pollint.intrvl)
			end*/
			transition -> Running
			event temp:wall_temp?temperature
				// just discard - this should only happen when in On or Off states
			
			// Messages that should not occur, but may occur
			/*transition -> Running
			event human_input?add_thermometer
			action do
				thermostat_output!prompt("Adding thermometers has been done and then blocked")
			end	
			transition -> Running
			event human_input?add_device
			action do
				human_output!prompt("Adding devices has been done and then blocked")
			end	
			// Messages the cannot occur - since they are always handled
			transition -> Running
			event human_input?SwitchOn
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOn at PIM.Running")
			end		
			transition -> Running
			event human_input?SwitchOff
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOff at PIM.Running")
			end*/		
			transition -> Running
			event thermostat_input?set_temperature
			action do
				thermostat_output!prompt("INTERNAL ERROR: Impossible set_temperature at PIM.Running")
			end		
		} // end Running
	} // end PIM_behavior
} // end PIM thing